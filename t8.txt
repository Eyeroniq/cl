In this simulation, we model a pool of stateless “Server” instances and a number of concurrent “Client” requests being funneled through a “LoadBalancer” that implements interchangeable strategies—here, Round-Robin and Least-Connections. Each Server simply tracks how many requests it is currently handling. The LoadBalancer maintains a list of servers and, upon each incoming request, consults its selected strategy object to pick the next server. In Round-Robin, we cycle through the list in turn; in Least-Connections, we pick whichever server currently has the fewest active requests. To simulate concurrency, we spin up a fixed thread pool and submit N dummy “requests,” each of which asks the LoadBalancer to dispatch it, waits a random short time to mimic processing, then signals completion so that the server’s active-request count is decremented. This setup demonstrates how different algorithms distribute load under simulated client bursts, and you can switch strategies at runtime by simply plugging in a different implementation of the LoadBalancingStrategy interface.

How it works in detail:

Server instances use an AtomicInteger to track their current load (activeRequests). When handleRequest is called, the counter increments, work is simulated on a separate thread (sleeping briefly), and then the counter decrements upon completion.

LoadBalancingStrategy is a simple interface with a single method selectServer(). We provide two implementations:

RoundRobinStrategy keeps a globally incremented index and uses modulo arithmetic to cycle through the server list.

LeastConnectionsStrategy scans all servers and picks the one with the fewest activeRequests.

LoadBalancer holds the server list and a mutable strategy. Requests arrive via handleRequest(), which delegates choice to the current strategy. You can change strategies at runtime through setStrategy().

In LoadBalancerSimulation, we instantiate three servers and a load balancer (initially with Round-Robin). We use a fixed thread pool to simulate concurrent clients submitting 30 requests, coordinating with a CountDownLatch to wait until all have been dispatched. After that batch completes, we switch to Least-Connections and repeat.

By examining the printed output, you’ll see how Round-Robin strictly rotates requests (regardless of current load), whereas Least-Connections adapts in real time, favoring any server whose simulated work has already completed faster. This illustrates both static and dynamic load-balancing approaches in a concise, configurable framework.